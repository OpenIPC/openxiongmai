#include "mpi_ae.h"
#include "mpi_awb.h"
#include "mpi_isp.h"
#include "xm_awb_comm.h"
#include "xm_comm_isp.h"
#include "xm_comm_sns.h"
#include "xm_sns_ctrl.h"
#include "xm_type.h"

#include "XAx_cmos.h"
#include "xm_print.h"

#define STATIC static
extern XM_U8 gu8MaxShutterOfst;
extern const XM_U16 gau16GainTbl_SmatSns[64];
extern XM_U32 gau32AllGain;
extern void (*pfn_gainLogic)(XM_U32 u32AllGain);

extern XM_S32 cmos_set_mirror_flip_sc2235(XM_U8 u8Mirror, XM_U8 u8Flip);
extern void
cmos_again_calc_table_sc2235(XM_U32 u32InTimes,
                             AE_SENSOR_GAININFO_S *pstAeSnsGainInfo);
extern XM_VOID cmos_gain_calc_table_com(XM_U32 u32InTimes,
                                        AE_SENSOR_GAININFO_S *pstAeSnsGainInfo);
extern XM_VOID cmos_inttime_update_sc2235(XM_U32 u32IntTime);
extern XM_VOID cmos_gains_update_sc2235(XM_U32 u32Again, XM_U32 u32Dgain);

STATIC XM_VOID cmos_dgain_calc_table(XM_U32 u32InTimes,
                                     AE_SENSOR_GAININFO_S *pstAeSnsGainInfo) {
  if (XM_NULL == pstAeSnsGainInfo) {
    return;
  }
  u32InTimes = u32InTimes / 32 * 2;
  if (u32InTimes < 1)
    u32InTimes = 1;
  pstAeSnsGainInfo->u32GainDb = u32InTimes;
  pstAeSnsGainInfo->u32SnsTimes = pstAeSnsGainInfo->u32GainDb * 16;
  return;
}

const static XM_U8 gau8Logic_sc1235[3][3] = {
    // 0x3631 0x3301 0x3633
    // AHD
    {0x84, 0x04, 0x2f},
    {0x88, 0x10, 0x23},
    {0x88, 0xb0, 0x43},
};

void gainLogic_sc1235(XM_U32 u32AllGain) {
  static XM_U8 su8Idx = 0xFF; //[bit0~bit3]:Vstd   [bit4~bit7]:Agc
  XM_U8 u8Idx2;
  //	XM_U8 u8Idx,u8Idx2;
  //	if(gu8Fps==50)		u8Idx = 0;
  //	else if(gu8Fps==60) 	u8Idx = 1;
  //	else					u8Idx = 2;
  if (u32AllGain < 32) {
    u8Idx2 = 0;
  } else if (u32AllGain < 64) {
    u8Idx2 = 1;
  } else {
    u8Idx2 = 2;
  }
  if (((su8Idx >> 4) & 0x0F) != u8Idx2) {
    su8Idx = ((u8Idx2 & 0x0F) << 4);
    sensor_write_register(0x3812, 0x00);
    sensor_write_register(0x3631, (XM_U32)gau8Logic_sc1235[u8Idx2][0]);
    sensor_write_register(0x3301, (XM_U32)gau8Logic_sc1235[u8Idx2][1]);
    sensor_write_register(0x3633, (XM_U32)gau8Logic_sc1235[u8Idx2][2]);
    sensor_write_register(0x3812, 0x30);
  }
}

/* the function of sensor set fps */
STATIC XM_VOID cmos_fps_set(XM_U8 u8Fps, AE_SENSOR_DEFAULT_S *pstAeSnsDft) {
  XM_U32 u32Pixs = 1920;
#ifdef RES_960
  gu16FullLines = 1000;
  switch (u8Fps) {
  case 30:
    u32Pixs = 2700;
    break;
  case 25:
  default:
    u32Pixs = 2700;
    break;
  }
#else
  gu16FullLines = HD720P_LINES;
  switch (u8Fps) {
  case 30:
    u32Pixs = 1600;
    break;
  case 25:
  default:
    u32Pixs = 1920;
    break;
  }
#endif
  if (pstAeSnsDft != NULL) {
    pstAeSnsDft->u32FullLinesStd = gu16FullLines;
    pstAeSnsDft->u32MaxIntTime =
        pstAeSnsDft->u32FullLinesStd - gu8MaxShutterOfst;
    pstAeSnsDft->u32LinesPer500ms = pstAeSnsDft->u32FullLinesStd * u8Fps / 2;
  }
  sensor_write_register(0x320c, (u32Pixs >> 8) & 0xFF);
  sensor_write_register(0x320d, u32Pixs & 0xFF);

  u32Pixs = u32Pixs - 36;
  sensor_write_register(0x3f04, (u32Pixs >> 8) & 0xFF);
  sensor_write_register(0x3f05, u32Pixs & 0xFF);
  gu8Fps = u8Fps;
  if (pfn_gainLogic) {
    (*pfn_gainLogic)(gau32AllGain);
  }
  return;
}

/****************************************************************************
 * callback structure                                                       *
 ****************************************************************************/
XM_S32 cmos_init_ae_exp_function_sc1235(AE_SENSOR_EXP_FUNC_S *pstExpFuncs) {
  pstExpFuncs->pfn_cmos_fps_set = cmos_fps_set;
  pstExpFuncs->pfn_cmos_slow_framerate_set = NULL;
  pstExpFuncs->pfn_cmos_inttime_update = cmos_inttime_update_sc2235;
  pstExpFuncs->pfn_cmos_gains_update = cmos_gains_update_sc2235;
  pstExpFuncs->pfn_cmos_again_calc_table = cmos_again_calc_table_sc2235;
  pstExpFuncs->pfn_cmos_dgain_calc_table = cmos_dgain_calc_table;
  pstExpFuncs->pfn_cmos_shut_calc_table = NULL;
  return 0;
}

#if (defined SOC_SYSTEM) || (defined SOC_ALIOS)
const ISP_CMOS_AGC_TABLE_S g_stIspAgcTable_sc1235 = {
    /* bvalid */
    1,
    /* 100, 200, 400, 800, 1600, 3200, 6400, 12800; 100, 200, 400, 800, 1600,
       3200, 6400, 12800 */
    //[0~7]:Normal
    /* sharpen_D	H	*/
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x14, 0x10, 0x10, 0x04, 0x04, 0x04, 0x04,
     0x04, 0x04, 0x04, 0x04},

    /* sharpen_Ud M */
    {0x20, 0x20, 0x20, 0x1C, 0x1C, 0x1A, 0x18, 0x18, 0x04, 0x04, 0x04, 0x04,
     0x04, 0x04, 0x04, 0x04},

    /* sharpen_Kd  */
    {0x31, 0x30, 0x30, 0x2C, 0x28, 0x1C, 0x18, 0x10, 0x08, 0x08, 0x08, 0x08,
     0x08, 0x08, 0x08, 0x08},

    /* snr_thresh 2DNr		*/
    {0x00, 0x01, 0x04, 0x10, 0x20, 0x28, 0x30, 0x40, 0x40, 0x40, 0x40, 0x40,
     0x40, 0x40, 0x40, 0x40},

    /* snr_thresh 3DNr	 Tf	*/
    {0x04, 0x06, 0x0A, 0x0E, 0x12, 0x15, 0x17, 0x18, 0x18, 0x18, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x18},

    /* snr_thresh 3DNr	 Sf	*/
    {0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
     0x10, 0x10, 0x10, 0x10},

    /* DyDpc_thresh 		*/
    {0x00, 0x00, 0x00, 0xA0, 0xD0, 0xD8, 0xE0, 0xE0, 0xE0, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF},

    /* saturation_strength */
    {0x92, 0x92, 0x92, 0x7F, 0x6E, 0x56, 0x32, 0x2D, 0x2D, 0x20, 0x20, 0x20,
     0x20, 0x20, 0x20, 0x20},

    /* Blc	*/
    {0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
     0x49, 0x49, 0x49, 0x49},

    /*Y_Tran gamma*/
    {0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
     0x32, 0x32, 0x32, 0x32},
};

const AE_SENSOR_DEFAULT_V2_S gstAeSnsDef_sc1235 = {2,
                                                   HD720P_LINES -
                                                       4, // minInt   	maxInt
                                                   1024,
                                                   15872, // minAgain maxAgain
                                                   16,
                                                   64,    // minDgain 	maxDgain
                                                   0xFFF, // maxIspGain
                                                   0x01010002, // Update
                                                   {700, 700, 700, 700},
                                                   0x00};

const ISP_COLORMATRIX_AUTO_S g_stAwbCcm_sc1235 = {
    5000,
    {
        0x0000,
        362,
        -98,
        -8,
        0x0000,
        -57,
        414,
        -101,
        0x0000,
        18,
        -147,
        385,
    },
    4000,
    {0x0000, 363, -114, 7, 0x0000, -81, 390, -53, 0x0000, 16, -186, 426},
    2800,
    {0x0000, 287, 6, -37, 0x0000, -99, 415, -60, 0x0000, -21, -239, 516}};

const ISP_AWB_CALIBRATION_V2_S gstAwbCal_sc1235 = {
    {0, 0, 4096, 2493, 3730, 1843, 2098, 4096},
    {4096, 3554, 0, 0, 3067, 2481, 4096, 1204},
    {-1225, -4096, -1951, -4096, -4096, -4096, -3525, -3137},
    213,
    0,
    1876,
    0,
    3297,
    {0, 994, 1282, 1626, 1736, 1881, 2145, 2158, 3297, 0, 0, 0, 0, 0, 0, 0},
    {2000, 2150, 2800, 4000, 4150, 5000, 6500, 7500, 12000, 0, 0, 0, 0, 0, 0,
     0},
    {1381, 1024, 1370, 0}};

static const XM_U16 gau16SnsInit_sc1235[][2] = {
#ifdef RES_960
    {0x0103, 0x01}, {0x0100, 0x00}, {0x3635, 0xa0}, {0x3305, 0x00},
    {0x363a, 0x1f}, {0x363b, 0x09}, {0x33b5, 0x10}, {0x4500, 0x59},
    {0x335c, 0x57}, {0x3d08, 0x02}, // 0x00
    {0x3621, 0x28}, {0x3303, 0x28}, {0x333a, 0x0a}, {0x3908, 0x11},
    {0x3366, 0x7c}, {0x3e08, 0x03}, {0x3e09, 0x10}, {0x3636, 0x25},
    {0x3625, 0x01}, {0x320c, 0x07}, {0x320d, 0x08}, {0x391e, 0x00},
    {0x3034, 0x05}, {0x330a, 0x01}, {0x3634, 0x21}, {0x3e01, 0x3e},
    {0x3364, 0x05}, {0x363c, 0x06}, {0x3637, 0x0e}, {0x335e, 0x01},
    {0x335f, 0x03}, {0x337c, 0x04}, {0x337d, 0x06}, {0x33a0, 0x05},
    {0x3301, 0x05}, {0x3302, 0xff}, {0x3633, 0x2f}, {0x330b, 0x6c},
    {0x3638, 0x0f}, {0x3306, 0x68}, {0x366e, 0x08}, {0x366f, 0x2f},
    {0x3e23, 0x07}, {0x3e24, 0x10}, {0x331d, 0x0a}, {0x333b, 0x00},
    {0x3357, 0x5a}, {0x3309, 0xa8}, {0x331f, 0x8d}, {0x3321, 0x8f},
    {0x3631, 0x84}, {0x3038, 0xff}, {0x391b, 0x4d}, {0x337f, 0x03},
    {0x3368, 0x02}, {0x3369, 0x00}, {0x336a, 0x00}, {0x336b, 0x00},
    {0x3367, 0x08}, {0x330e, 0x30}, {0x3213, 0x02}, {0x3802, 0x01},
    {0x3235, 0x03}, {0x3236, 0xe6}, {0x3208, 0x05}, {0x3209, 0x0A}, // 0x08
    {0x320a, 0x03}, {0x320b, 0xc8}, {0x3211, 0x03},                 // 0x04
    {0x3f00, 0x07}, {0x3f04, 0x06}, {0x3f05, 0xe4}, {0x5780, 0xff},
    {0x5781, 0x04}, {0x5785, 0x18}, {0x3622, 0x06}, {0x3630, 0x28},
    {0x3313, 0x05}, {0x3639, 0x09}, {0x3640, 0x03}, // 0x00
#if 1                                               // 36M
    {0x3039, 0x35}, {0x303a, 0xA6},
#else // 27M
    {0x3039, 0x31}, {0x303a, 0xC6},
#endif
    {0x3641, 0x02}, {0x3D08, 0x03}, {0x0100, 0x01},
#else
    {0x0100, 0x00}, {0x3635, 0xa0}, {0x3305, 0x00}, {0x3639, 0x0c},
    {0x363a, 0x1f}, {0x363b, 0x09}, {0x33b5, 0x10}, {0x4500, 0x59},
    {0x335c, 0x57}, {0x3d08, 0x00}, {0x3621, 0x28}, {0x3303, 0x28},
    {0x333a, 0x0a}, {0x3908, 0x11}, {0x3366, 0x7c}, {0x3e08, 0x03},
    {0x3e09, 0x10}, {0x3636, 0x25}, {0x3625, 0x01}, {0x391e, 0x00},
    {0x330a, 0x01}, {0x3634, 0x21}, {0x3364, 0x05}, {0x363c, 0x06},
    {0x3637, 0x0e}, {0x335e, 0x01}, {0x335f, 0x03}, {0x337c, 0x04},
    {0x337d, 0x06}, {0x33a0, 0x05}, {0x3301, 0x05}, {0x3302, 0xff},
    {0x3633, 0x2f}, {0x330b, 0x6c}, {0x3630, 0xa8}, {0x3622, 0x02},
    {0x3638, 0x0f}, {0x366e, 0x08}, {0x366f, 0x2f}, {0x3e23, 0x07},
    {0x3e24, 0x10}, {0x331d, 0x0a}, {0x333b, 0x00}, {0x3357, 0x5a},
    {0x3309, 0xa8}, {0x331f, 0x8d}, {0x3321, 0x8f}, {0x3631, 0x84},
    {0x3038, 0xff}, {0x391b, 0x4d}, {0x3670, 0x00}, // 0x08
    {0x367e, 0x07}, {0x367f, 0x0f}, {0x3677, 0x2f}, {0x3678, 0x23},
    {0x337f, 0x03}, {0x3368, 0x02}, {0x3369, 0x00}, {0x336a, 0x00},
    {0x336b, 0x00}, {0x3367, 0x08}, {0x330e, 0x30}, {0x3213, 0x02},
    {0x3802, 0x01}, {0x3235, 0x02}, {0x3236, 0xec}, {0x3679, 0x43},
    {0x3208, 0x05}, {0x3209, 0x08}, {0x320a, 0x02}, {0x320b, 0xd8},
    {0x3211, 0x04}, {0x320c, 0x06},                 // 1600
    {0x320d, 0x40}, {0x320e, 0x02}, {0x320f, 0xee}, // 750
    {0x3202, 0x00}, {0x3203, 0x78}, {0x3206, 0x03}, {0x3207, 0x57},
    {0x3039, 0x25},
#if 0 // FPGA   (ExtClk: 36M)
	{0x303a,0xd6},	// 0xc6
	{0x330b,0x3c},
#else
    {0x303a, 0xc6},
#endif
    {0x3034, 0x23}, {0x3035, 0xc2}, {0x3306, 0x50}, {0x3e01, 0x2e},
    {0x3e02, 0x00}, {0x3640, 0x02}, // 0x00
    {0x3641, 0x02},                 // 0x00
    {0x3D08, 0x03},                 // 0x02
    {0x0100, 0x01},                 // Stream Enable
#endif
};

XM_U32 sensor_getlist_sc1235(XM_U16 *pu16Num) {
  *pu16Num = sizeof(gau16SnsInit_sc1235) / sizeof(gau16SnsInit_sc1235[0]);
  return (XM_U32)gau16SnsInit_sc1235;
}

#endif
